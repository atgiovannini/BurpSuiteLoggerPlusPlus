options {
    MULTI=true;
    STATIC=false;
    LOOKAHEAD=3;
//    DEBUG_PARSER = true;
}

PARSER_BEGIN(FilterParser)
package loggerplusplus.filter.parser;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.regex.Pattern;
import java.util.HashMap;

public class FilterParser {

    public FilterParser(String s){
        this(new StringReader(s));
    }

    public static void main(String[] args) throws IOException {
        String str;
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        while(!(str = in.readLine()).equalsIgnoreCase("END")) {
            try {
                SimpleNode root = parseFilter(str);
                root.dump("");
            } catch (Throwable e) {
                System.out.println("Syntax check failed: " + e.getMessage());
            }
        }
    }

    public static SimpleNode parseFilter(String string) throws IOException, ParseException {
        FilterParser FilterParser = new FilterParser(string);
        SimpleNode node = FilterParser.Root();
        return node;
    }
}

PARSER_END(FilterParser)

SKIP:  { " " }
TOKEN [IGNORE_CASE]: {
    <EQ: "=" | "==" >
    | <NEQ: "!=" >
    | <GT: ">" >
    | <LT: "<" >
    | <GEQ: ">=" >
    | <LEQ: "<=" >
    | <OR: "|" | "||" | "OR" >
    | <AND: "&" | "&&" | "AND" >
    | <XOR: "^" | "XOR">
    | <BOOLEAN: "TRUE" | "FALSE">
    | <SINGLEQUOTEDSTRING: "'" ("\\" ~[] | ~["\'", "\\"])* "'" >
    | <DOUBLEQUOTEDSTRING: "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >
    | <NUMBER: ("-"|"+")?(<DIGIT>)+("."(<DIGIT>)+)?>
    | <DIGIT: ["0"-"9"] >
    | <REGEXLITERAL: "/\\Q" ("\\" ~["E"] | ~["\\"])* "\\E/" >
    | <REGEX: "/" ("\\" ~[] | ~["/", "\\"])* "/" >
    | <LPAREN: "(" >
    | <RPAREN: ")" >
    | <INVERSE: "!" | "NOT" >
    | <CONTAINS: "CONTAINS" >
    | <IN: "IN" >
    | <BOOLEANIDENTIFIER: "COMPLETE" | "PARAMS" | "ISSSL" | "HASQUERYSTRINGPARAM" | "HASBODYPARAM"
                            | "HASCOOKIEPARAM" | "HASSETCOOKIES" >
    | <STRINGIDENTIFIER: (["a"-"z","A"-"Z"])+ >
    | <NUMERICIDENTIFIER: "RESPONSELENGTH" | "STATUS" | "RTT" | "TARGETPORT" | "REQUESTLENGTH" >
}

SimpleNode Root() #ROOT :
{}
{
    Filter() <EOF>
    {
        return jjtThis;
    }
}

SimpleNode Filter() #FILTER :
{Token inverse = null;}
{
    ( //Recursive to handle brackets nicely optional invertor
        [inverse=<INVERSE>] <LPAREN> Filter() <RPAREN>
        | Expression()
    )

    ((And() | Or() | Xor()) Filter())*

    {
        jjtThis.inverse = inverse != null;
        return jjtThis;
    }
}

void Expression() #EXPRESSION:
{
    ASTIDENTIFIER leftIdentifier = null, rightIdentifier = null;
}
{
    (Boolean() | BooleanIdentifier()) BooleanOperator() (Boolean() | BooleanIdentifier())


//    Identifier() (BooleanComparison() | NumericalComparison() | StringComparison()) //Identifier OP Value
//    | Identifier() (Eq() | Neq() | Xor() | Lt() | Leq() | Gt() | Geq()) Identifier()//Identifier - Identifier Comparison - ALL OPS
//    | (Number() | String() | Regex()) (Eq() | Neq()) Identifier()                   //Standard EQ/NEQ Ops - Value OP Identifier
//    | Number() (Lt() | Leq() | Gt() | Geq()) Identifier()                           //Number Specific Ops - Number OP Identifier
//    | Boolean() Xor() Identifier()                                                  //Boolean Specific Op - Boolean OP Identifier
}

void BooleanComparison():
{}
{
    (Eq() | Neq() | Xor())
}

void NumericalComparison():
{}
{
    (Eq() | Neq() | Lt() | Gt() | Leq() | Geq())
}

void StringComparison():
{}
{
    (Eq() | Neq())
}

Float Number() #NUMBER :
{Token t;}
{
    t=<NUMBER>
    {jjtThis.value = Float.parseFloat(t.image); return (Float) jjtThis.value;}
}

String String() #STRING :
{Token t;}
{
    ( t=<SINGLEQUOTEDSTRING> | t=<DOUBLEQUOTEDSTRING> )

    {
        jjtThis.value = t.image.substring(1,t.image.length()-1);
        return org.apache.commons.text.StringEscapeUtils.unescapeJava((String) jjtThis.value);
    }
}

Pattern Regex() #REGEX :
{Token t;}
{
    ( t=<REGEXLITERAL> | t=<REGEX> )
    {
        return Pattern.compile(t.image.substring(1,t.image.length()-1), Pattern.CASE_INSENSITIVE);
    }
}

SimpleNode BooleanIdentifier() #BOOLEANIDENTIFIER :
{Token t, inverse=null;}
{
    [inverse=<INVERSE>]
    t=<IDENTIFIER>
    {
        jjtThis.data.put("inverse", inverse != null);
        return jjtThis;
    }
}

Boolean Boolean() #BOOLEAN :
{Token t, inverse=null;}
{
    [inverse=<INVERSE>]
    t=<BOOLEAN>
    {
        jjtThis.value = (inverse != null ^ Boolean.parseBoolean(t.image));
        return (Boolean) jjtThis.value;
    }
}

void BooleanOperator() :
{}{
    <EQ> | <NEQ> | <XOR>
}

void Contains() #CONTAINS :
{}
{
    <CONTAINS>
}

void In() #IN :
{}
{
    <IN>
}

void Eq() #EQ :
{Token t;}
{
    t=<EQ> {jjtThis.value = t.image;}
}
void Neq() #NEQ :
{Token t;}
{
    t=<NEQ> {jjtThis.value = t.image;}
}
void Gt() #GT :
{Token t;}
{
    t=<GT> {jjtThis.value = t.image;}
}
void Geq() #GEQ :
{Token t;}
{
    t=<GEQ> {jjtThis.value = t.image;}
}
void Lt() #LT :
{Token t;}
{
    t=<LT> {jjtThis.value = t.image;}
}
void Leq() #LEQ :
{Token t;}
{
    t=<LEQ> {jjtThis.value = t.image;}
}
void And() #AND :
{Token t;}
{
    t=<AND> {jjtThis.value = t.image;}
}
void Or() #OR :
{Token t;}
{
    t=<OR> {jjtThis.value = t.image;}
}
void Xor() #XOR :
{Token t;}
{
    t=<XOR> {jjtThis.value = t.image;}
}