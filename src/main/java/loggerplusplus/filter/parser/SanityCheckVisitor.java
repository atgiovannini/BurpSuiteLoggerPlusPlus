/* Generated By:JavaCC: Do not edit this line. FilterParserDefaultVisitor.java Version 7.0.2 */
package loggerplusplus.filter.parser;

import loggerplusplus.LogEntryField;
import loggerplusplus.filter.Operator;
import org.apache.commons.lang3.StringUtils;

import java.util.Arrays;
import java.util.Date;
import java.util.regex.Pattern;

public class SanityCheckVisitor implements FilterParserVisitor{
  public VisitorData defaultVisit(SimpleNode node, VisitorData data){
    node.childrenAccept(this, data);
//    System.out.println("Evaluating Node: " + node);
    return data;
  }
  public VisitorData visit(SimpleNode node, VisitorData data){
    return defaultVisit(node, data);
  }

  public VisitorData visit(SimpleNode node){
    return visit(node, new VisitorData());
  }

  public VisitorData visit(ASTExpression node, VisitorData data){
    return defaultVisit(node, data);
  }
  public VisitorData visit(ASTComparison node, VisitorData visitorData){
    defaultVisit(node, visitorData);

    Class leftType, rightType;
    leftType = (node.left instanceof ASTIdentifier) ? ((ASTIdentifier) node.left).type : node.left.getClass();
    rightType = (node.right instanceof ASTIdentifier) ? ((ASTIdentifier) node.right).type : node.right.getClass();
    if(leftType == null || rightType == null) return visitorData;

    if(node.operator == Operator.LESS_THAN || node.operator == Operator.LESS_THAN_EQUAL
            || node.operator == Operator.GREATER_THAN || node.operator == Operator.GREATER_THAN_EQUAL){
        boolean valid = (Date.class.isAssignableFrom(leftType) || Date.class.isAssignableFrom(rightType))
                        || (Number.class.isAssignableFrom(leftType) && Number.class.isAssignableFrom(rightType));
        if(!valid){
            visitorData.addError(String.format("Operator %s cannot be used to compare values of type %s and %s.",
                    node.operator, leftType.getTypeName(), rightType.getTypeName()));
        }
    }else if(node.left instanceof Pattern){
      visitorData.addError("The left operand of a comparison cannot be a pattern.");
    }else if(node.right instanceof Pattern && !String.class.isAssignableFrom(leftType)){
      visitorData.addError("Regular expressions can only be used on string elements.");
    }else if(node.operator == Operator.CONTAINS && !(String.class.isAssignableFrom(leftType) && String.class.isAssignableFrom(leftType))){
      visitorData.addError("The contains operator can only be used on string elements.");
    }

    return visitorData;
  }

  public VisitorData visit(ASTIdentifier node, VisitorData visitorData){
    LogEntryField.Group fieldGroup = LogEntryField.Group.findByLabel(node.group);
    if(fieldGroup == null){
      visitorData.addError(String.format("Group \"%s\" is not valid. Valid groups are: %s",
              node.group, Arrays.toString(LogEntryField.Group.values())));
    }else {
      LogEntryField field = LogEntryField.getByLabel(fieldGroup, node.field);
      if(field == null){
        visitorData.addError(String.format("\"%s\" is not field in group \"%s\". Valid fields are: \n%s",
                node.field, node.group, StringUtils.join(LogEntryField.getFieldsInGroup(fieldGroup).keySet(), ", \n")));
      }else{
        if(node.inverse && field.getType() != Boolean.class){
          visitorData.addError(String.format("Field \"%s\" with type \"%s\" cannot be inverted.",
                  node.field, field.getType().getTypeName()));
        }else if(field == LogEntryField.NUMBER){
          visitorData.addError("Number field cannot be used within filters.");
        }
        node.type = field.getType();
        node.logEntryField = field;
      }
    }
    return visitorData;
  }
}
/* JavaCC - OriginalChecksum=b30458d637879c9662107beea18204f0 (do not edit this line) */
