/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Filter.jj */
/*@egen*/options {
               
    STATIC=false;
                 
                           
    DEBUG_PARSER = true;
}

PARSER_BEGIN(FilterParser)
package loggerplusplus.filter.parser;
import loggerplusplus.filter.Operator;
import loggerplusplus.filter.BooleanOperator;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.regex.Pattern;
import java.util.HashMap;

public class FilterParser/*@bgen(jjtree)*/implements FilterParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTFilterParserState jjtree = new JJTFilterParserState();

/*@egen*/

    public FilterParser(String s){
        this(new StringReader(s));
    }

    public static void main(String[] args) throws IOException {
        String str;
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        while(!(str = in.readLine()).equalsIgnoreCase("END")) {
            try {
                SimpleNode root = parseFilter(str);
                root.dump("");
            } catch (Throwable e) {
                System.out.println("Syntax check failed: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    public static SimpleNode parseFilter(String string) throws IOException, ParseException {
        FilterParser FilterParser = new FilterParser(string);
        SimpleNode node = FilterParser.Filter();
        return node;
    }
}

PARSER_END(FilterParser)

SKIP:  { " " }
TOKEN [IGNORE_CASE]: {
    <EQ: "=" | "==" >
    | <NEQ: "!=" >
    | <GT: ">" >
    | <LT: "<" >
    | <GEQ: ">=" >
    | <LEQ: "<=" >
    | <OR: "|" | "||" | "OR" >
    | <AND: "&" | "&&" | "AND" >
    | <XOR: "^" | "XOR">
    | <BOOLEAN: "TRUE" | "FALSE">
    | <SINGLEQUOTEDSTRING: "'" ("\\" ~[] | ~["\'", "\\"])* "'" >
    | <DOUBLEQUOTEDSTRING: "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >
    | <NUMBER: ("-"|"+")?(<DIGIT>)+("."(<DIGIT>)+)?>
    | <DIGIT: ["0"-"9"] >
    | <REGEXLITERAL: "/\\Q" ("\\" ~["E"] | ~["\\"])* "\\E/" >
    | <REGEX: "/" ("\\" ~[] | ~["/", "\\"])* "/" >
    | <LPAREN: "(" >
    | <RPAREN: ")" >
    | <INVERSE: "!" | "NOT" >
//    | <CONTAINS: "CONTAINS" >
//    | <IN: "IN" >
    | <IDENTIFIER: (["a"-"z","A"-"Z"])+ >
}



ASTExpression Filter()             :
{/*@bgen(jjtree) Expression */
 ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Boolean inverse=false;
 loggerplusplus.filter.BooleanOperator op = null;
}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    ([inverse=Inverse()] <LPAREN> Expression() [(op=And() Expression())+ | (op=Or() Expression())+ | (op=Xor() Expression())+] <RPAREN>
    | Expression() [(op=And() Expression())+ | (op=Or() Expression())+ | (op=Xor() Expression())+])

    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.op = op;
        jjtn000.inverse = inverse;
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTExpression Expression()             :
{/*@bgen(jjtree) Expression */
 ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Boolean inverse = null;
 loggerplusplus.filter.BooleanOperator op = null;
}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    //Recursive to handle brackets nicely - optional invertor
    ([inverse=Inverse()] <LPAREN> (Comparison() | Expression()) [(op=And() Expression())+ | (op=Or() Expression())+ | (op=Xor() Expression())+] <RPAREN>
    | Expression() | Comparison())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.op = op;
        jjtn000.inverse = inverse != null;
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


//Comparisons always made up of 3 nodes. Value Operation Value
ASTComparison Comparison()            :
{/*@bgen(jjtree) Comparison */
 ASTComparison jjtn000 = new ASTComparison(JJTCOMPARISON);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Operator op;
 Object left, right;
 Boolean value;
}
{/*@bgen(jjtree) Comparison */
    try {
/*@egen*/
    left = Value() op = Operator() right = Value()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.left = left;
        jjtn000.right = right;
        jjtn000.operator = op;
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTSimpleBoolean SimpleBoolean()                :
{/*@bgen(jjtree) SimpleBoolean */
 ASTSimpleBoolean jjtn000 = new ASTSimpleBoolean(JJTSIMPLEBOOLEAN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Object value;}
{/*@bgen(jjtree) SimpleBoolean */
    try {
/*@egen*/
    value = Identifier() | value = Boolean()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = value;
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Object Value()      :
{Object v;}
{
    (v = Identifier() | v = Number() | v = Boolean() | v = String() | v = Regex())
    {return v;}
}


//IDENTIFIERS
String Identifier()      :
{Token t;}
{
    t=<IDENTIFIER>
    { return t.image; }
}

//END IDENTIFIERS


//TYPES

Float Number()       :
{Token t;}
{
    t=<NUMBER>
    {return Float.parseFloat(t.image);}
}

String String()       :
{Token t;}
{
    ( t=<SINGLEQUOTEDSTRING> | t=<DOUBLEQUOTEDSTRING> )

    {
        String s = t.image.substring(1,t.image.length()-1);
        return org.apache.commons.text.StringEscapeUtils.unescapeJava(s);
    }
}

Pattern Regex()       :
{Token t;}
{
    ( t=<REGEXLITERAL> | t=<REGEX> )
    {
        return Pattern.compile(t.image.substring(1,t.image.length()-1), Pattern.CASE_INSENSITIVE);
    }
}

Boolean Boolean()       :
{Token t, inverse=null;}
{
    [inverse=<INVERSE>]
    t=<BOOLEAN>
    {
        return (inverse != null ^ Boolean.parseBoolean(t.image));
    }
}

//END TYPES


//BASIC OPERATORS

Operator Operator()       :
{}
{
      <EQ>  {return Operator.EQUAL;}
    | <NEQ> {return Operator.NOT_EQUAL;}
    | <GT>  {return Operator.GREATER_THAN;}
    | <LT>  {return Operator.LESS_THAN;}
    | <GEQ> {return Operator.GREATER_THAN_EQUAL;}
    | <LEQ> {return Operator.LESS_THAN_EQUAL;}
}

boolean Inverse()       :
{}
{
    <INVERSE> {return true;}
}

BooleanOperator And()       :
{}
{
    <AND> {return BooleanOperator.AND;}
}

BooleanOperator Or()       :
{}
{
    <OR> {return BooleanOperator.OR;}
}

BooleanOperator Xor()       :
{}
{
    <XOR> {return BooleanOperator.XOR;}
}